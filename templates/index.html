<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BharatKhoj</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Favicon - Points to a local static file -->
    <link rel="icon" type="image/png" href="/static/favicon.png">
    <!-- OpenSearch Description - Link to your opensearch.xml file -->
    <link rel="search" type="application/opensearchdescription+xml" title="BharatKhoj" href="/opensearch.xml">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            transition: opacity 0.3s ease-in-out; /* Smooth transition for UI changes */
        }
        /* Custom styles for the logo text colors */
        .logo-bharat .blue { color: #4285F4; } /* Google Blue */
        .logo-bharat .red { color: #EA4335; }  /* Google Red */
        .logo-bharat .yellow { color: #FBBC05; } /* Google Yellow */
        .logo-bharat .blue-dark { color: #4285F4; } /* Google Blue for Khoj */
        .logo-bharat .green { color: #34A853; } /* Google Green */

        /* Loading spinner */
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #4285F4;
            animation: spin 1s ease infinite;
            display: none; /* Hidden by default */
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Styles for the offline game container */
        .offline-game-container {
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 600px;
            background-color: #f7fafc; /* Light background for the game */
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 2rem;
        }

        /* Running Man Game Canvas */
        #runningManGameCanvas {
            background-color: #ffffff; /* White background for canvas */
            border-radius: 0.5rem;
            display: block; /* Ensures canvas is not inline */
            margin-top: 1rem;
            box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.1);
            border: 1px solid #e2e8f0;
        }

        /* Custom Autocomplete Styles */
        .autocomplete-container {
            position: relative; /* Needed for absolute positioning of dropdown */
            width: 100%;
        }
        .autocomplete-dropdown {
            position: absolute;
            top: 100%; /* Position below the input */
            left: 0;
            right: 0;
            background-color: #fff;
            border: 1px solid #e2e8f0;
            border-top: none;
            border-radius: 0 0 0.5rem 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000; /* Ensure it appears above other content */
        }
        .autocomplete-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            font-size: 1rem;
            color: #4A5568;
        }
        .autocomplete-item:hover, .autocomplete-item.selected {
            background-color: #f0f4f8; /* Lighter background on hover/selection */
        }
        .autocomplete-item strong {
            font-weight: 600;
            color: #2D3748; /* Darker color for matched part */
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center justify-center py-10 px-4 sm:px-6 lg:px-8">

    <!-- Offline Game Container (Hidden by default) -->
    <div id="offlineGame" class="offline-game-container text-gray-800">
        <!-- Updated messages -->
        <h2 class="text-3xl font-bold mb-2 text-center">‡§á‡§Ç‡§ü‡§∞‡§®‡•á‡§ü ‡§ï‡§®‡•á‡§ï‡•ç‡§∂‡§® ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à üòî</h2>
        <p class="mb-4 text-center">Play until your internet is back! <br/>‡§ú‡§¨ ‡§§‡§ï ‡§Ü‡§™‡§ï‡§æ ‡§á‡§Ç‡§ü‡§∞‡§®‡•á‡§ü ‡§µ‡§æ‡§™‡§∏ ‡§® ‡§Ü ‡§ú‡§æ‡§è, ‡§§‡§¨ ‡§§‡§ï ‡§ñ‡•á‡§≤‡•á‡§Ç!</p>
        <canvas id="runningManGameCanvas" width="600" height="150"></canvas>
        <div class="mt-4 flex space-x-4">
            <button id="startGameBtn" class="px-6 py-3 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition duration-300 ease-in-out">
                Start Game (Spacebar)
            </button>
            <button id="resetGameBtn" class="px-6 py-3 bg-gray-300 text-gray-800 font-semibold rounded-lg shadow-md hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2 transition duration-300 ease-in-out">
                Reset
            </button>
        </div>
        <p id="gameScore" class="text-xl font-bold mt-4">Score: 0</p>
    </div>

    <!-- Main Search UI Container -->
    <div id="searchUI" class="max-w-4xl w-full bg-white p-8 rounded-xl shadow-lg">
        <!-- Header with Logo and Title -->
        <div class="flex flex-col items-center mb-8">
            <!-- Text-based Logo for BharatKhoj (reverted) -->
            <h1 class="text-5xl font-extrabold text-gray-800 flex flex-col items-center mb-6">
                <div class="logo-bharat text-6xl">
                    <span class="blue">B</span><span class="red">h</span><span class="yellow">a</span><span class="blue-dark">r</span><span class="green">a</span><span class="red">t</span>
                </div>
                <div class="flex items-center space-x-2 text-4xl text-blue-dark mt-2">
                    <span>Khoj</span>
                    <!-- Simple SVG Magnifying Glass Icon -->
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-8 h-8 text-yellow-500">
                        <path fill-rule="evenodd" d="M10.5 3.75a6.75 6.75 0 1 0 0 13.5 6.75 6.75 0 0 0 0-13.5ZM2.25 10.5a8.25 8.25 0 1 1 14.59 5.28l4.69 4.69a.75.75 0 1 1-1.06 1.06l-4.69-4.69A8.25 8.25 0 0 1 2.25 10.5Z" clip-rule="evenodd" />
                    </svg>
                </div>
            </h1>
            
            <!-- Search Form -->
            <form action="/" method="POST" class="w-full flex flex-col sm:flex-row items-center gap-4" onsubmit="showLoading()">
                <div class="autocomplete-container flex-grow">
                    <input
                        type="text"
                        name="query"
                        id="searchQuery"
                        value="{{ query }}"
                        placeholder="Search for anything..."
                        class="w-full px-5 py-3 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent text-lg text-gray-700"
                        autofocus
                        autocomplete="off" <!-- Important for custom autocomplete -->
                    >
                    <div id="autocompleteDropdown" class="autocomplete-dropdown hidden"></div>
                </div>
                
                <button
                    type="submit"
                    id="searchButton"
                    class="w-full sm:w-auto px-6 py-3 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition duration-300 ease-in-out text-lg"
                >
                    Search
                </button>
            </form>
        </div>

        <!-- Loading Indicator -->
        <div id="loadingIndicator" class="flex flex-col items-center justify-center mt-8 p-6 text-indigo-600" style="display: none;">
            <div class="spinner"></div>
            <p class="mt-4 text-lg font-medium">Searching BharatKhoj...</p>
        </div>

        <!-- Error Message Display -->
        {% if api_error %}
            <div id="errorMessage" class="mt-8 p-6 bg-red-100 border border-red-300 text-red-800 rounded-lg text-center">
                <p class="text-lg font-medium">{{ api_error }}</p>
            </div>
        {% elif user_message %}
            <div id="userMessage" class="mt-8 p-6 bg-blue-100 border border-blue-300 text-blue-800 rounded-lg text-center">
                <p class="text-lg font-medium">{{ user_message }}</p>
            </div>
        {% endif %}

        <!-- Search Results Section -->
        {% if results %}
            <h2 class="text-3xl font-bold text-gray-800 mt-8 mb-6 border-b-2 border-indigo-500 pb-2">Results for "{{ query }}"</h2>
            <ul class="space-y-6">
                {% for item in results %}
                    <li class="bg-gray-50 p-6 rounded-lg shadow-sm hover:shadow-md transition duration-200 ease-in-out">
                        <h3 class="text-xl font-semibold text-indigo-700 mb-2">
                            <a href="{{ item.url }}" target="_blank" rel="noopener noreferrer" class="hover:underline">{{ item.title }}</a>
                        </h3>
                        <p class="text-gray-700 mb-2 leading-relaxed">{{ item.snippet }}</p>
                        <p class="text-sm text-green-700 truncate">
                            <a href="{{ item.url }}" target="_blank" rel="noopener noreferrer" class="hover:underline">{{ item.url }}</a>
                        </p>
                    </li>
                {% endfor %}
            </ul>

            <!-- Pagination Controls -->
            <div class="flex justify-between items-center mt-8">
                {% if prev_start %}
                    <a href="/?query={{ query|urlencode }}&start={{ prev_start }}" class="px-6 py-3 bg-gray-200 text-gray-800 font-semibold rounded-lg shadow-md hover:bg-gray-300 transition duration-300 ease-in-out">
                        Previous
                    </a>
                {% else %}
                    <span class="px-6 py-3 bg-gray-100 text-gray-500 rounded-lg cursor-not-allowed">Previous</span>
                {% endif %}

                <span class="text-gray-600 font-medium">Page {{ (start - 1) / 10 + 1 | int }}</span>

                {% if next_start %}
                    <a href="/?query={{ query|urlencode }}&start={{ next_start }}" class="px-6 py-3 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition duration-300 ease-in-out">
                        Next
                    </a>
                {% else %}
                    <span class="px-6 py-3 bg-gray-100 text-gray-500 rounded-lg cursor-not-allowed">Next</span>
                {% endif %}
            </div>
        {% elif query %}
            <div id="noResultsMessage" class="mt-8 p-6 bg-yellow-100 border border-yellow-300 text-yellow-800 rounded-lg text-center">
                <p class="text-lg font-medium">No results found for "{{ query }}". Please try a different query.</p>
            </div>
        {% endif %}
    </div>

    <script>
        // Wrap the entire script content in an IIFE to create an isolated scope
        (function() {
            const loadingIndicator = document.getElementById('loadingIndicator');
            const searchUI = document.getElementById('searchUI');
            const offlineGame = document.getElementById('offlineGame');
            const searchQueryInput = document.getElementById('searchQuery');
            const autocompleteDropdown = document.getElementById('autocompleteDropdown'); // New: Custom dropdown
            let currentSuggestions = []; // Store fetched suggestions
            let selectedSuggestionIndex = -1; // For keyboard navigation
            let debounceTimeout; // For debouncing input

            // --- Loading Indicator Functions ---
            function showLoading() {
                if (searchUI.style.display !== 'none') {
                    loadingIndicator.style.display = 'flex';
                }
            }

            // --- Offline Game Logic (Running Man Game) ---
            const canvas = document.getElementById('runningManGameCanvas');
            const ctx = canvas.getContext('2d');
            const startGameBtn = document.getElementById('startGameBtn');
            const resetGameBtn = document.getElementById('resetGameBtn');
            const gameScoreDisplay = document.getElementById('gameScore');

            const groundY = canvas.height - 20;
            const man = { x: 50, y: groundY - 40, width: 20, height: 40, jumping: false, jumpVelocity: 0 };
            let obstacles = [];
            let score = 0;
            let gameSpeed = 3;
            let gameFrame = 0;
            let gameOverFlag = false;
            let gameLoopId;

            function drawMan() {
                if (gameSpeed > 3 && !man.jumping) {
                    ctx.fillStyle = `rgba(180, 180, 180, ${0.5 - (gameFrame % 10) * 0.05})`;
                    ctx.fillRect(man.x - 5 - (gameFrame % 10) * 0.5, man.y + man.height / 2, 5, 2);
                    ctx.fillRect(man.x - 10 - (gameFrame % 10) * 0.5, man.y + man.height / 2 - 5, 5, 2);
                }

                ctx.fillStyle = '#4A5568';

                ctx.fillRect(man.x + (man.width / 4), man.y, man.width / 2, man.height / 4);
                ctx.fillRect(man.x, man.y + man.height / 4, man.width, man.height / 2);

                const legShift = (Math.floor(gameFrame / 5) % 2 === 0) ? 2 : -2;
                
                ctx.fillRect(man.x + 2, man.y + man.height * 3 / 4 + legShift, man.width / 3, man.height / 4);
                ctx.fillRect(man.x + man.width - man.width / 3 - 2, man.y + man.height * 3 / 4 - legShift, man.width / 3, man.height / 4);
            }

            function drawObstacle(obs) {
                ctx.fillStyle = '#48BB78';
                ctx.fillRect(obs.x, groundY - obs.height, obs.width, obs.height);
            }

            function clearCanvas() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }

            function updateScore() {
                gameScoreDisplay.textContent = 'Score: ' + Math.floor(score / 10);
            }

            function checkCollision(man, obstacle) {
                return man.x < obstacle.x + obstacle.width &&
                    man.x + man.width > obstacle.x &&
                    man.y < groundY &&
                    man.y + man.height > groundY - obstacle.height;
            }

            function generateObstacle() {
                const obstacleWidth = 10 + Math.random() * 20;
                const obstacleHeight = 20 + Math.random() * 30;
                obstacles.push({ x: canvas.width, width: obstacleWidth, height: obstacleHeight });
            }

            function gameLoop() {
                if (gameOverFlag) {
                    return;
                }

                gameLoopId = requestAnimationFrame(gameLoop);

                gameFrame++;
                score++;
                updateScore();

                if (gameFrame % 300 === 0) {
                    gameSpeed += 0.7;
                }

                if (gameFrame % 150 === 0) {
                    generateObstacle();
                }
                

                clearCanvas();
                drawMan();

                if (man.jumping) {
                    man.y += man.jumpVelocity;
                    man.jumpVelocity += 0.5;
                    if (man.y >= groundY - man.height) {
                        man.y = groundY - man.height;
                        man.jumping = false;
                        man.jumpVelocity = 0;
                    }
                }

                for (let i = 0; i < obstacles.length; i++) {
                    obstacles[i].x -= gameSpeed;
                    drawObstacle(obstacles[i]);

                    if (checkCollision(man, obstacles[i])) {
                        gameOver();
                        return;
                    }
                }

                obstacles = obstacles.filter(obs => obs.x + obs.width > 0);
            }

            function startGame() {
                if (gameLoopId) return;
                resetGame();
                gameOverFlag = false;
                gameLoopId = requestAnimationFrame(gameLoop);
                document.addEventListener('keydown', handleKeyDown);
            }

            function resetGame() {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
                gameOverFlag = false;
                man.x = 50; man.y = groundY - man.height; man.jumping = false; man.jumpVelocity = 0;
                obstacles.length = 0;
                score = 0;
                gameSpeed = 3;
                gameFrame = 0;
                updateScore();
                clearCanvas();
                drawMan();
                document.removeEventListener('keydown', handleKeyDown);
            }

            function gameOver() {
                gameOverFlag = true;
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
                ctx.fillStyle = '#E53E3E';
                ctx.font = 'bold 30px Inter';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 15);
                ctx.font = '15px Inter';
                ctx.fillText('Score: ' + Math.floor(score / 10), canvas.width / 2, canvas.height / 2 + 15);
                document.removeEventListener('keydown', handleKeyDown);
            }

            function handleKeyDown(event) {
                if (event.code === 'Space' && !man.jumping && !gameOverFlag) {
                    man.jumping = true;
                    man.jumpVelocity = -10;
                }
                if (event.code === 'Space' && gameOverFlag) {
                    startGame();
                }
            }
            
            startGameBtn.addEventListener('click', startGame);
            resetGameBtn.addEventListener('click', resetGame);

            clearCanvas();
            drawMan();
            updateScore();

            // --- Online/Offline UI Switching Logic ---
            function showOfflineGame() {
                searchUI.style.display = 'none';
                offlineGame.style.display = 'flex';
                resetGame();
            }

            function showSearchUI() {
                offlineGame.style.display = 'none';
                searchUI.style.display = 'block';
                loadingIndicator.style.display = 'none';
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }

            function checkOnlineStatus() {
                if (navigator.onLine) {
                    showSearchUI();
                } else {
                    showOfflineGame();
                }
            }

            window.addEventListener('online', checkOnlineStatus);
            window.addEventListener('offline', showOfflineGame);

            document.addEventListener('DOMContentLoaded', () => {
                checkOnlineStatus();
            });

            // --- Custom Search Suggestions (Autocomplete) ---
            searchQueryInput.addEventListener('input', function() {
                clearTimeout(debounceTimeout); // Clear previous timeout
                const query = this.value;
                autocompleteDropdown.innerHTML = ''; // Clear existing suggestions
                autocompleteDropdown.classList.add('hidden'); // Hide dropdown by default
                selectedSuggestionIndex = -1; // Reset selection

                if (query.length > 1) {
                    debounceTimeout = setTimeout(async () => { // Debounce API call
                        try {
                            const response = await fetch(`/suggest?q=${encodeURIComponent(query)}`);
                            currentSuggestions = await response.json(); // Store suggestions
                            
                            if (currentSuggestions.length > 0) {
                                autocompleteDropdown.classList.remove('hidden'); // Show dropdown
                                currentSuggestions.forEach((s, index) => {
                                    const item = document.createElement('div');
                                    item.classList.add('autocomplete-item');
                                    // Highlight matching part of the suggestion
                                    const regex = new RegExp(query, 'gi');
                                    item.innerHTML = s.replace(regex, '<strong>$&</strong>');
                                    
                                    item.addEventListener('click', () => {
                                        searchQueryInput.value = s;
                                        autocompleteDropdown.innerHTML = '';
                                        autocompleteDropdown.classList.add('hidden');
                                    });
                                    autocompleteDropdown.appendChild(item);
                                });
                            }
                        } catch (error) {
                            console.error('Error fetching suggestions:', error);
                        }
                    }, 300); // 300ms debounce delay
                }
            });

            // --- Keyboard Navigation for Custom Suggestions ---
            searchQueryInput.addEventListener('keydown', function(event) {
                if (autocompleteDropdown.classList.contains('hidden') || currentSuggestions.length === 0) {
                    return; // Only proceed if dropdown is visible and has suggestions
                }

                const items = autocompleteDropdown.children;

                if (event.key === 'ArrowDown') {
                    event.preventDefault(); // Prevent cursor from moving in input
                    if (selectedSuggestionIndex < currentSuggestions.length - 1) {
                        if (selectedSuggestionIndex !== -1) {
                            items[selectedSuggestionIndex].classList.remove('selected');
                        }
                        selectedSuggestionIndex++;
                        items[selectedSuggestionIndex].classList.add('selected');
                        searchQueryInput.value = currentSuggestions[selectedSuggestionIndex]; // Update input with selected suggestion
                    }
                } else if (event.key === 'ArrowUp') {
                    event.preventDefault(); // Prevent cursor from moving in input
                    if (selectedSuggestionIndex > 0) {
                        if (selectedSuggestionIndex !== -1) {
                            items[selectedSuggestionIndex].classList.remove('selected');
                        }
                        selectedSuggestionIndex--;
                        items[selectedSuggestionIndex].classList.add('selected');
                        searchQueryInput.value = currentSuggestions[selectedSuggestionIndex]; // Update input with selected suggestion
                    }
                } else if (event.key === 'Enter') {
                    if (selectedSuggestionIndex !== -1) {
                        event.preventDefault(); // Prevent form submission if a suggestion is selected
                        searchQueryInput.value = currentSuggestions[selectedSuggestionIndex];
                        autocompleteDropdown.innerHTML = '';
                        autocompleteDropdown.classList.add('hidden');
                        // Optionally, submit the form immediately after selection
                        document.querySelector('form').submit(); 
                    }
                } else if (event.key === 'Escape') {
                    autocompleteDropdown.innerHTML = '';
                    autocompleteDropdown.classList.add('hidden');
                    selectedSuggestionIndex = -1;
                } else if (event.code === 'Tab') { // Existing Tab to select first option
                    if (currentSuggestions.length > 0) {
                        event.preventDefault(); 
                        searchQueryInput.value = currentSuggestions[0];
                        autocompleteDropdown.innerHTML = '';
                        autocompleteDropdown.classList.add('hidden');
                    }
                }
            });

            // Hide suggestions when clicking outside the input/dropdown
            document.addEventListener('click', function(event) {
                if (!searchQueryInput.contains(event.target) && !autocompleteDropdown.contains(event.target)) {
                    autocompleteDropdown.innerHTML = '';
                    autocompleteDropdown.classList.add('hidden');
                    selectedSuggestionIndex = -1;
                }
            });

            // Ensure suggestions are hidden when input loses focus but not due to clicking a suggestion
            searchQueryInput.addEventListener('blur', function() {
                // Use a small timeout to allow click event on suggestion to fire first
                setTimeout(() => {
                    if (!autocompleteDropdown.contains(document.activeElement)) {
                        autocompleteDropdown.innerHTML = '';
                        autocompleteDropdown.classList.add('hidden');
                        selectedSuggestionIndex = -1;
                    }
                }, 100);
            });
        })(); // End of IIFE
    </script>
</body>
</html>